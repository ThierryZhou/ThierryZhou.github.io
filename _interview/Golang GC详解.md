---
titile: Golang GC详解
---

## 概述

垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。

Golang在GC的演进过程中也经历了很多次变革，Go V1.3之前的标记-清除(mark and sweep)算法，Go V1.3之前的标记-清扫(mark and sweep)的缺点

Go V1.5的三色并发标记法

Go V1.5的三色标记为什么需要STW

Go V1.5的三色标记为什么需要屏障机制(“强-弱” 三色不变式、插入屏障、删除屏障 )

Go V1.8混合写屏障机制

Go V1.8混合写屏障机制的全场景分析

### 标记-清扫算法



### 三色标记算法

算法流程：
1. 遍历根对象的第一层可达对象标记为灰色, 不可达默认白色
2. 将灰色对象的下一层可达对象标记为灰色, 自身标记为黑色
3. 多次重复步骤2, 直到灰色对象为0, 只剩下白色对象和黑色对象
4. sweep 白色对象

示例：
1. 遍历根对象的第一层可达对象标记为灰色, 不可达默认白色
![3color-flow-1](/assets/images/posts/3color-flow-1.png)

2. 将灰色对象 A 的下一层可达对象标记为灰色, 自身标记为黑色
![3color-flow-2](/assets/images/posts/3color-flow-2.png)

3. 继续遍历灰色对象的下层对象,重复步骤2
![3color-flow-3](/assets/images/posts/3color-flow-3.png)

4. 继续遍历灰色对象的下层对象,重复步骤2
![3color-flow-4](/assets/images/posts/3color-flow-4.png)

5. 扫描结束后，回收所有白色的节点。

### 三色标记算法的问题

我们加入如果没有STW，那么也就不会再存在性能上的问题，那么接下来我们假设如果三色标记法不加入STW会发生什么事情？
我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性，我们来看看一个场景，如果三色标记法, 标记过程不使用STW将会发生什么事情?

我们把初始状态设置为已经经历了第一轮扫描，目前黑色的有对象1和对象4， 灰色的有对象2和对象7，其他的为白色对象，且对象2是通过指针p指向对象3的，如图所示。

![problem-1](/assets/images/posts/gc-problem-1.png)

现在如何三色标记过程不启动STW，那么在GC扫描过程中，任意的对象均可能发生读写操作，如图所示，在还没有扫描到对象2的时候，已经标记为黑色的对象4，此时创建指针q，并且指向白色的对象3。

![problem-2](/assets/images/posts/gc-problem-2.png)

与此同时灰色的对象2将指针p移除，那么白色的对象3实则就是被挂在了已经扫描完成的黑色的对象4下，如图所示。

![problem-3](/assets/images/posts/gc-problem-3.png)

然后我们正常指向三色标记的算法逻辑，将所有灰色的对象标记为黑色，那么对象2和对象7就被标记成了黑色，如图所示。

![problem-4](/assets/images/posts/gc-problem-4.png)

那么就执行了三色标记的最后一步，将所有白色对象当做垃圾进行回收，如图所示。

![problem-5](/assets/images/posts/gc-problem-5.png)

但是最后我们才发现，本来是对象4合法引用的对象3，却被GC给“误杀”回收掉了。

可以看出，有两种情况，在三色标记法中，是不希望被发生的。

条件1: 一个白色对象被黑色对象引用(白色被挂在黑色下)
条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)
如果当以上两个条件同时满足时，就会出现对象丢失现象!

并且，如图所示的场景中，如果示例中的白色对象3还有很多下游对象的话, 也会一并都清理掉。

### 三色一致性

为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是STW的过程有明显的资源浪费，对所有的用户程序都有很大影响。那么是否可以在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？ 三色一致性是目前 Golang 使用的机制，尝试去破坏上面的两个必要条件就可以了。

强三色不变性（strong tri-color invariant）：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象。

![consistent-1](/assets/images/posts/consistent-1.png)

弱三色不变性（weak tri-color invariant）：即便黑色对象指向白色对象，那么从灰色对象出发，总存在一条可以找到该白色对象的路径。

![consistent-2](/assets/images/posts/consistent-2.png)

## 写屏障

##### 1. 插入屏障

具体操作: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)

满足: 强三色不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)


##### 2. 删除屏障

具体操作: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。

满足: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)


## 混合写屏障

插入写屏障和删除写屏障的短板：

插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；
删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。
Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。

具体操作:

1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，

2、GC期间，任何在栈上创建的新对象，均为黑色。

3、被删除的对象标记为灰色。

4、被添加的对象标记为灰色。

满足: 变形的弱三色不变式.


## 工作流程

### GC 触发时机

在 Go 中主要会在三个地方触发 GC：

1、监控线程 runtime.sysmon 定时调用；

2、手动调用 runtime.GC 函数进行垃圾收集；

3、申请内存时 runtime.mallocgc 会根据堆大小判断是否调用；

